# 변수의 유효범위와 클로저
- 자바스크립트는 함수 지향 언어: 함수 동적 생성, 인수로 사용, 호출 등 가능 - 자유도
- 함수 내부에서 외부의 변수 접근 가능

### 코드 블록
- 코드 블록 {...} 안에서 선언한 변수는 안에서만 사용 가능

### 중첩 함수
- 함수 내부에서 선언한 함수 '중첩(nested) 함수'
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
```
- 중첩 함수는 그 자체로 반환될 수 있고 어디서든 반환된 함수는 어디서든 호출 가능



- 만약 counter를 여러 개 만들면 count 변수는 어떻게 될까?
## 렉시컬 환경
- 명세서에만 존재하는 이론상의 객체

### 1. 변수
- 실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경(Lexical Environment)라는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.
- 렉시컬 환경 객체 구성
  1) 환경 레코드(Environment Record): 모든 지역 변수를 프로퍼티로 저장하는 객체, this 같은 기타 정보
  2) 외부 렉시컬 환경 (Outer Lexical Environment)에 대한 참조: 외부 코드와 연관
  
- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티. 즉, '변수 가져오기나 변경'은 '환경 레코드의 프로퍼티 가져오기나 변경'을 의미한다.
```javascript
let p = 'h'; ..... Lexical Environment: [ p : 'h' ] - outer -> null
                                        환견 레코드  외부 참조  참조x
```

- 스크립트 전체와 관련된 렉시컬 환경: 전역 렉시컬 환경

- 코드 실행 후 진행에 따른 렉시컬 환경 변화
```javascript
실 행    ..... Lexical Environment: [ p : <uninitialized> ] - outer -> null
let p;   ..... Lexical Environment: [ p : undefined ] 
p = 'h'; ..... Lexical Environment: [ p : "h" ] 
p = 'b'; ..... Lexical Environment: [ p : "b" ] 
```

### 2. 함수 선언문
- 함수 선언문으로 선언한 함수는 일반 변수와 달리 바로 초기화
- 변수는 let을 만나 선언이 될 때까지 사용할 수 없지만 함수는 선언되기 전에 렉시컬 환경 생성 즉시 사용 가능

```javascript
실 행    ..... Lexical Environment: [ p : <uninitialized> ] - outer -> null
                                    [ say: function       ]
let p;   ..... Lexical Environment: [   ...               ]
p = 'h'; ..... Lexical Environment: 
funtion say(name){
  alert(name);
}
```
- 변수에 할당한 함수 표현식은 해당하지 않음 (let say = funtion(name){...})

### 3. 내부와 외부 렉시컬 환경
- 함수 호출 시 새로운 렉시컬 환경 자동 생성
- 이 환경엔 호출 시 넘겨받은 매개변수와 함수의 지역 변수 저장

- say("John") 호출 시 내부 변화
```javascript
                          내부 렉시컬 환경 
                          Lexical Environment of the calllet              외부(전역) 렉시컬 환경
let p = "h";
funtion say(name){      [  name: John  ] - outer -> (호출 시점 현재 상태) [ say: function ]  - outer -> null
alert( `${name}, ${p});                                                   [ p: 'h'        ]
}
say("John");
```

  - 내부 프로퍼티: name
  - 외부 프로퍼티: p와 함수 say
  - 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 가짐
  
  
  
### 4. 반환 함수
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

- makeCounter() 호출 시 새로운 렉시컬 환경 객체 생성 -> 지역 변수 저장
```javascript
                            내부 렉시컬 환경 
                            makeCounter() call                          외부(전역) 렉시컬 환경
function makeCounter(){  
  let count = 0;           [  count: 0  ]   - outer -> (호출 시점 현재 상태) [ makeCounter: function ]  - outer -> null
  return function(){                                                         [ counter: undefined   ]
   return count++;
  };
}
let counter = makeCounter();
```
- 현재 중첩함수는 생성 후 실행되지 않은 상태
- 모든 함수는 생성된 곳의 렉시컬 환경을 기억하는 숨김 프로퍼티 존재 [[Environment]](렉시컬 환경 참조)
- 호출 장소와 상관없이 자신이 생성된 곳 기억하는 이유: [[Environment]]
  - counter() 호출마다(새로운 함수 생성) 새로운 렉시컬 환경 생성 -> 프로퍼티에 위치 참조

```javascript
                               내부               외부  렉시컬 환경 
                          중첩 익명 함수        makeCounter() call                          외부(전역) 렉시컬 환경
function makeCounter(){  
  let count = 0;                              ->  [  count: 0  ]   - outer -> (현재) [ makeCounter: function ]  - outer -> null
  return function(){    ... [<empty>] - outer                                                     [ counter: undefined   ]
   return count++;
  };
}
let counter = makeCounter();
```
- 중첩 함수로 넘어가면 count 변수를 자체 렉시컬 환경에서 먼저 찾음
- 익명 중첩 함수엔 지역변수가 없으므로 외부 렉시컬 환경에서 찾음
- 변수 값 갱신은 변수가 저장된 렉시컬 환경에서 이루어짐

## 클로저 (Closure)
  - 외부 변수를 기억하고 접근할 수 있는 함수
  - 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수
  - 자바스크립트는 모든 함수가 클로저가 됨 (except: new function 문법)
  
```javascript
function outer(){
  let x = 10;
  function inner(){
    x++;
  }
}
```
- outer() 호출 시 inner() 함수에서 x가 자신의 유효 범위가 아님에도, outer() 함수에 정의된 변수를 참조
- inner() 함수를 클로저라고 하며, outer() 함수에서 정의된 변수 x를 자유 변수라고 한다. => 클로저: 자유변수에 닫혀있다/엮여있다.
- 함수형 언어가 아니면 inner() 함수의 유효 범위(scope) 밖 즉 outer() 내부에 존재하는 변수, 함수에 접근할 수 없다.
- JS는 함수가 선언될 당시의 유효한 환경을 기억하고 있다가 함수를 호출할 때 그 환경을 사용할 수 있다.

- 요약: 함수는 숨김 프로퍼티 [[Environment]]를 갖고 자신의 생성 위치 기억, 외부 변수에 접근
 
 ### 클로저 캡슐화
 - 클로저 덕분에 변수또는 함수를 private로 활용할 수 있다.

예제 - 비동기
```javascript
function count() {
    for (var i = 1; i < 10; i++) {
        setTimeout(function(){
            console.log(i);
        }, 1000);
    }
}
count();
```
 - count() 함수 호출 시 반복문 9번 수행하는데 변수 i 공유
 - setTimeout()으로 1초 뒤에 호출하면 10을 9 번 출력, 1초 기다리는 동안 이미 반복문은 모두 수행됨.
 
 
 해결1 - 즉시 실행함수
 ```javascript 
 function count() {
    for (var i = 1; i < 10; i++) {
        (function(count){
            setTimeout(function(){
                console.log(count);
            }, 1000);
        })(i);
    }
}
count();
 ```
  - i 값을 인자로 넘겨줌
  
  
  해결2 - 블록 스코프(let)
  ```javascript
  function count() {
    for (let i = 1; i < 10; i++) {
        setTimeout(function(){
            console.log(i);
        }, 1000);
    }
}
count();
  ```
  - 각 반복문 단계가 같은 변수 i를 공유하지 않음.
 
 

## 가비지 컬렉션
- 함수 호출 종료 시 해당 렉시컬 환경 메모리에서 제거
- 호출 종료 후 여전히 도달 가능한 중첩 함수 존재 가능, 중첩함수의 [[Environment]] 프로퍼티에 외부 함수 렉시컬 환경 정보 저장 -> 도달 가능 상태
```javascript
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는
// 렉시컬 환경 정보가 저장됩니다.
// g함수에 f함수의 렉시커 환경 저장?
```

### 최적화 프로세스
- 이론상 함수가 살아있는 동안 모든 외부 변수 메모리에 유지
- 실제 자바스크립트 엔진이 최적화 => 변수 사용 분석 후 사용되지 않으면 메모리에서 제거
- 디버깅 시 일시중지 상태에서 해당 변수가 undefined로 뜨는 이유



## 연습 문제
```javascript

let x = 1;
function a() {
  console.log(x); //Cannot access 'x' before initialization
  let x = 2;
}
a();
```
```javascript

let x = 1;
function a() {
  console.log(x); 

}
a(); // 1
```


<처>
- https://ko.javascript.info/closure
- https://victorydntmd.tistory.com/44#comment12007195
