# Module
- 애플리케이션의 크기가 커지면서 파일을 여러 개로 분리할 때 분리된 파일
- 대개는 클래스 하나, 특정 목적의 복수의 함수로 구성된 라이브러리 하나로 구성
- `파일 하나`, 스크립트 하나는 모듈 하나

## 지시자
- `export`: 변수나 함수 앞에 붙여 외부 모듈에서 해당 변수나 함수에 접근 가능 (모듈 내보내기)
- `import`: 외부 모듈의 기능을 가져올 수 있다. (모듈 가져오기)

## 브라우저에서 동작
- 모듈은 특수 키워드나 기능과 함께 사용되므로 `<script type="module">` 같은 속성을 설정해 해당 스크립트가 모듈이란 걸 브라우저가 알 수 있도록 해준다.
```html
<!doctype html>
<script type="module">
  import {sayHi} from './say.js';

  document.body.innerHTML = sayHi('John');
</script>
```
```javascript
export function sayHi(user) {
  return `Hello, ${user}!`;
}
```
- 모듈을 사용한 웹페이지를 local로 열면 `import/export`가 작동하지 않는다.
- 테스트를 위해 `static-server`나 `live server`을 사용해야 한다.

<br>

## 핵심 기능
### '엄격 모드'로 실행
- 모듈은 항상 `엄격 모드`로 실행
- 선언되지 않은 변수에 값을 할당하는 등의 코드는 에러

### 모듈 레벨 스코프
- 모듈은 자신만의 스코프 존재
- 모듈 내부에서 정의한 변수나 함수는 다른 스크립트에서 접근할 수 없다.
- 외부 공개하려는 모듈은 `export`하고 `import`로 가져와야 한다.
```html
<!doctype html>
<script type="module" src="hello.js"></script>
```
```javascript
// user.js
export let user = "John";
```
```javascript
// hello.js
import {user} from './user.js';
document.body.innerHTML = user; // John
```

### 단 한 번만 평가됨
- 동일한 모듈이 여러 곳에서 사용되도 모듈은 `최초 호출 시 단 한번만 실행`
- 실행 후 결과는 이 모듈을 가져가려는 모든 모듈에 내보내진다.
- 최상위 레벨 모듈을 대게 초기화나 내부 데이터 구조를 만들 때 사용 (재사용)
```javascript
alert("모듈"); // alert.js
```
```javascript
//1.js
import `./alert.js`; // alert: 모듈
//2.js
import `./alert.js`; // 아무 일도 안 생김
```
- 객체 내보내기 (admin 객체 전달)
```javascript
// 📁 admin.js
export let admin = {
  name: "John"
};
```
```javascript
// 📁 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// 📁 2.js
import {admin} from './admin.js';
alert(admin.name); // Pete

// 1.js와 2.js 모두 같은 객체를 가져오므로
// 1.js에서 객체에 가한 조작을 2.js에서도 확인할 수 있습니다.
```
- 모듈은 단 한번만 실행되고 실행된 모듈은 필요한 곳에 `공유`
- 어느 한 모듈이 객체를 수정하면 다른 모듈에서 변경사항 확인 가능

### import.meta
- 현재 모듈에 대한 정보를 제공해주는 객체
- 브라우저 환경에선 스크립트의 url 정보 얻을 수 있음
- HTML 안에 있는 모듈이면, 현재 실행 중인 웹페이지의 URL 정보 얻을 수 있다.
```javascript
<script type="module">
  alert(import.meta.url); // script URL (인라인 스크립트가 위치해 있는 html 페이지의 URL)
</script>
```

### 'this’는 undefined
- 모듈 최상위 레벨의 `this`는 `undefined`: 엄격 모드라서?

<br><br>

## 브라우저 특정 기능
- 브라우저 환경에서 `type="module"`이 붙은 스크립트와 일반 스크립트와의 다른점

### 1. 지연 실행
- 외부 스크립트, 인라인 스크립트와 관계없이 마치 `defer` 속성을 붙인 것처럼 실행

<img src="https://github.com/in3166/TIL/blob/main/JavaScript/img/defer0.png" />
<img src="https://github.com/in3166/TIL/blob/main/JavaScript/img/defer.png" />

- 외부 모듈 스크립트 `<script type="module" src="..." />`을 다운로드할 때 브라우저의 HTML 처리가 멈추지 않는다. (외부 모듈과 리소스들을 '병렬적'으로 불러옴)
- HTML 문서가 완전히 준비될 때까지 `준비 상태`로 있다가 문서가 완전히 만들어진 후 실행 (defer)
- 스크립트의 상대적 순서가 유지. 문서상 위쪽의 스크립트부터 차례로 실행
- **모듈을 사용할 땐 HTML 페이지가 완전히 나타난 이후에 모듈이 실행된다는 점에 항상 유의**

### 2. 인라인 스크립트의 비동기 처리
- 일반 스크립트에서 `async` 속성은 외부 스크립트를 불러올 때만 유효, (로딩이 끝나면 다른 스크립트나 HTML 문서가 처리되길 기다리지 않고 바로 실행)
- 모듈 스크립트는 `async` 속성을 '인라인 스크립트에서도 적용' 가능
- 가져오기 작업이 끝나면 바로 실행되기 때문에 광고, 문서 레벨 이벤트 리스너, 카운터 같이 `종속되지 않은 기능 구현` 유용

```js
<!-- 필요한 모듈(analytics.js)의 로드가 끝나면 -->
<!-- 문서나 다른 <script>가 로드되길 기다리지 않고 바로 실행됩니다.-->
<script async type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
```
- 가져오기(`./analytics.js`) 작업이 끝나면 HTML 파싱이 끝나지 않았거나 다른 스크립트가 대시 상태에 있더라도 모듈이 바로 실행

### 3. 외부 스크립트
- `type="module"` 붙은 외부 모듈 스크립트 2가지 특징

1) `src` 속성값이 동일한 외부 스크립트는 한 번만 실행
```javascript
<!-- my.js는 한번만 로드 및 실행됩니다. -->
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```

2) 외부 사이트같이 다른 오리진에서 불러오면 fetch와 Cross-Origin 요청에서 처럼 `CORS 헤더` 필요
- 모듈이 저장된 원격 서버가 `Access-Control-Allow-Origin: *` 헤더를 제공해야만 불러올 수 있음
```JAVASCript
<!-- another-site.com이 Access-Control-Allow-Origin을 지원해야만 외부 모듈을 불러올 수 있습니다.-->
<!-- 그렇지 않으면 스크립트는 실행되지 않습니다.-->
<script type="module" src="http://another-site.com/their.js"></script>
```

### 4. ‘경로가 없는’ 모듈은 금지
- 브라우저 환경에서 `import`는 반드시 상대 혹은 절대 URL 앞에 와야하고 없으면 무효 처리
- 브라우저와 달리 Node.js나 번들링 툴은 경로가 없어도 해당 모듈 찾을 방법을 알아 사용 가능
```JS
import {sayHi} from 'sayHi'; // Error!
// './sayHi.js'와 같이 경로 정보를 지정해 주어야 합니다.
```

### 5. 호환을 위한 ‘nomodule’
- 구식 브라우저 `type="module" 해석 불가해서 무시하고 넘어감
- `nomodule` 속성으로 대비 가능
```javascript
<script type="module">
  alert("모던 브라우저를 사용하고 계시군요.");
</script>

<script nomodule>
  alert("type=module을 해석할 수 있는 브라우저는 nomodule 타입의 스크립트는 넘어갑니다. 따라서 이 alert 문은 실행되지 않습니다.")
  alert("오래된 브라우저를 사용하고 있다면, type=module이 붙은 스크립트는 무시합니다. 대신 이 alert 문이 실행됩니다.");
</script>
```

### 빌드 툴
- 브라우저 환경에서 모듈을 단독으로 잘 사용하지 않고 `웹팩(Webpack)`같은 툴을 사용해 모듈을 한 데 묶어(번들링) 프로덕션 서버에 올리는 방식 사용
- 번들러 사용 시 모듈 분해 통제 가능, 경로가 없는 모듈이나 CSS/HTML 포멧의 모듈 사용 가능하게 해준다.
<br>

- 역할
1. HTML `<script type="module">`에 넣을 `주요 모듈` 선택 (진입점 역할하는 모듈)
2. `주요 모듈`에 의존하는 모듈 분석을 시작으로 모듈 간의 의존 관계 파악
3. 모듈 전체를 모아 하나의 클 파일을 만든다.(설정으로 여러 개도 가능) 이 과정에서 `import`문이 번들러 내 함수로 대체되므로 기존 기능 유지
4. 이런 과정 중 변형이나 최적화 함께 수행
    - 도달 가능하지 않은 코드 삭제
    - 내보내진 모듈 중 쓰임처 없는 모듈 삭제 (가지 치기)
    - `console`, `debugger` 같은 개발 관련 코드 삭제
    - 최신 자바스크립트 문법이 사용된 경우 `바벨(Babel)` 사용하여 변환
    - 공백 제거, 변수 이름 줄이기 등 크기 줄임

- 번들링 툴 사용 시 하나/여러 개 파일로 번들링
- 번들링 전 스크립트에 있던 `import/export` 문은 특별한 번들러 함수로 대체
- 번들러 과정이 끝나면 기존 스크립트에서 `import/export` 문이 사리지므로 `type="module"`이 필요 없어져 일반 스크립트 취급
```javascript
<!-- 웹팩과 같은 툴로 번들링 과정을 거친 스크립트인 bundle.js -->
<script src="bundle.js"></script>
```

<br><br><br>
<출처>
- https://ko.javascript.info/modules-intro
