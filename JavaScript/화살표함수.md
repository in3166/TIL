## 화살표 함수
- 자신의 this, argument, super, new.target(함수나 생성자가 new로 호출됐는지 감지)을 바인딩 하지 않음
- 항상 익명 (name이 없음)
- 메서드 함수가 아닌 곳에 적합하고 생성자로 사용 불가

- function 사용
```javascript
let fu = function(arg, ...){
  return 2;
}
```

### 기본 문법


- 매개변수 X
```javascript
let fu = () => console.log('1');
fu(); // 1
```

- 매개변수 하나
```javascript
let fu = x => x;
fu('1'); // 1
```

- 매개변수 여러개
```javascript
let fu = (a, b) => a + b; // 한 줄일 때는 {} 없이 반환
let fu = (a, b) => {return a + b}; // {}이 있으면 return 필수!
```

- 객체 반환
```javascript
let fu = () => ({ a : 1, b : 2});
fu(); // { a : 1, b : 2}
```

### 일반 함수와 화살표 함수의 차이점
 - 일반 함수가 전역 컨텍스트에서 실행될 때 this가 정의됨.
 - 함수의 내부함수, 콜백함수의 this는 window 객체
 
```javascript
let cat = {
  sound: "meow",
  soundPlay: function() {
    console.log(this); // 1
    setTimeout(function (){
      console.log(this); // 2
      console.log(this.sound); // 3 
    }, 1000);
  }
}
1: cat , 2: windouw, 3: undefined
```

- 일반함수에 this 전달
```javascript
// 변수 전달
let cat = {
	sound: "meow",
  	soundPlay: function () {
      	let that = this // that 사용
		setTimeout(function () {
			console.log(that.sound);
		}, 1000);
    }
}

// bind 사용
let cat = {
	sound: "meow",
  	soundPlay: function () {
		setTimeout(function () {
			console.log(this.sound);
		}.bind(this), 1000); // bind 사용
    }
}

cat.soundPlay();
```

### 화살표 함수
```javascript
let cat = {
	sound: "meow",
  	soundPlay: function () {
		setTimeout(() => {
			console.log(this.sound);
		}, 1000);
    }
}

cat.soundPlay(); // meow
```
- 클러저 함수처럼 바깥의 함수에 
<br><br>

## 바인딩 되지 않은 this
- 새로운 일반 함수는 어떻게 호출됐느냐에 따라 자신의 `this` 값을 정의했다. 
  - 함수가 생성자 -> 새로운 객체
  - 엄격 모드 함수 호출 -> undefined
  - 함수가 객체 메서드 -> 문맥 겍체
-> 객체 지향 스타일에 안좋음

```javascript
function Person() {
  // Person() 생성자는 `this`를 자신의 인스턴스로 정의.
  this.age = 0;

  setInterval(function growUp() {
    // 비엄격 모드에서, growUp() 함수는 `this`를
    // 전역 객체로 정의하고, 이는 Person() 생성자에
    // 정의된 `this`와 다름.
    this.age++;
  }, 1000);
}

var p = new Person();
```
- ECMAScript 3/5에선 비전역 변수에 할당해서 해결
```javsscript
function Person() {
  var that = this;
  that.age = 0;

  setInterval(function growUp() {
    // 콜백은  `that` 변수를 참조하고 이것은 값이 기대한 객체이다.
    that.age++;
  }, 1000);
}
```
<br>

- 화살표 함수는 자신의 this가 없다.
- 화살표 함수는 렉시컬 범위의 this 사용
- 일반 변수 조회 규칙을 따르기 때문에 ***현재 범위에서 존재하지 않는 this 찾을 때, 바로 바깥 범위 검색***
```javascript
function Person(){
  this.age = 0;

  setInterval(() => {
    this.age++; // |this|는 Person 객체를 참조
  }, 1000);
}

var p = new Person();
```
<br><br>

## 엄격 모드와의 관계
- this가 렉시컬임을 감안하면 엄격 모드 규칙은 그냥 무시

```javascript
var f = () => { 'use strict'; return this; };
f() === window; // 혹은 전역객체
```

## call 또는 apply를 통한 피호출
- this가 바인디오디지 않으므로 인자만 전달가능
- this.md에 더 자세한 설명

## 바인딩 되지 않은 arguments
- arguments 객체를 바인드하지 않음
- arguments는 둘러싸는 범위 내 이름에 대한 참조
```javascript
var arguments = [1, 2, 3];
var arr = () => arguments[0];

arr(); // 1

function foo(n) {
  var f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
  return f();
}

foo(1); // 2
```

## 메서드로 사용되는 화살표 함수
```javascript
'use strict';

var obj = { // does not create a new scope
  i: 10,
  b: () => console.log(this.i, this),
  c: function() {
    console.log( this.i, this)
  }
}
obj.b(); // prints undefined, Window {...} (or the global object)
obj.c(); // prints 10, Object {...}
```

<출처>
- https://velog.io/@ki_blank/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98Arrow-function
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98
